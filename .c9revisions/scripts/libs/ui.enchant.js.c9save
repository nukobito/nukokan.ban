{"ts":1370352710563,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * @fileOverview\n * ui.enchant.js v2 (2012/11/05)\n * ui parts support\n * @require enchant.js v0.5.2 or later\n * @require image files for gamepad, icons (default: pad.png, apad.png, icon0.png, font0.png)\n *\n * @features\n * - D-Pad (left, right, up, down)\n * - Analog Pad\n * - Button (3 built-in themes and can be customized)\n * - MutableText\n * - ScoreLabel\n * - TimeLabel\n * - LifeLabel\n * - Bar\n * - VirtualMap\n *\n * @usage\n * [D-Pad]\n *      var pad = new Pad();\n *      pad.x = 0;\n *      pad.y = 220;\n *      core.rootScene.addChild(pad);\n *  (input of X direction can be detected from \"Xbuttonup\" \"Xbuttondown\" events\n *   or enchant.Core.instance.input.X)\n *\n * [A-Pad]\n *      var pad = new APad();\n *      pad.x = 0;\n *      pad.y = 220;\n *      core.rootScene.addChild(pad);\n *  (input can be detected from pad.vx/vy and pad.touched)\n *\n * [Button]\n *      var button = new Button(\"Press me\");\n *      button.addEventListener(\"touchstart\", function(){ ... })\n *      core.rootScene.addEventListener(button);\n *\n *      var button_light = new Button(\"Press me\", \"light\");\n *      core.rootScene.addEventListener(button);\n *\n *      var button_blue = new Button(\"Press me\", \"blue\");\n *      core.rootScene.addEventListener(button);\n */\n\n/**\n * @type {Object}\n */\nenchant.ui = { assets: ['pad.png', 'apad.png', 'icon0.png', 'font0.png'] };\n\n/**\n * 方向キーパッドのクラス: Pad\n * @scope enchant.ui.Pad\n */\nenchant.ui.Pad = enchant.Class.create(enchant.Sprite, {\n    /**\n     * 方向キーパッドオブジェクトを作成する。\n     * @constructs\n     * @extends enchant.Sprite\n     */\n    initialize: function() {\n        var core = enchant.Core.instance;\n        var image = core.assets['pad.png'];\n        enchant.Sprite.call(this, image.width / 2, image.height);\n        this.image = image;\n        this.input = { left: false, right: false, up: false, down: false };\n        this.addEventListener('touchstart', function(e) {\n            this._updateInput(this._detectInput(e.localX, e.localY));\n        });\n        this.addEventListener('touchmove', function(e) {\n            this._updateInput(this._detectInput(e.localX, e.localY));\n        });\n        this.addEventListener('touchend', function(e) {\n            this._updateInput({ left: false, right: false, up: false, down: false });\n        });\n    },\n    _detectInput: function(x, y) {\n        x -= this.width / 2;\n        y -= this.height / 2;\n        var input = { left: false, right: false, up: false, down: false };\n        if (x * x + y * y > 200) {\n            if (x < 0 && y < x * x * 0.1 && y > x * x * -0.1) {\n                input.left = true;\n            }\n            if (x > 0 && y < x * x * 0.1 && y > x * x * -0.1) {\n                input.right = true;\n            }\n            if (y < 0 && x < y * y * 0.1 && x > y * y * -0.1) {\n                input.up = true;\n            }\n            if (y > 0 && x < y * y * 0.1 && x > y * y * -0.1) {\n                input.down = true;\n            }\n        }\n        return input;\n    },\n    _updateInput: function(input) {\n        var core = enchant.Core.instance;\n        ['left', 'right', 'up', 'down'].forEach(function(type) {\n            if (this.input[type] && !input[type]) {\n                core.dispatchEvent(new enchant.Event(type + 'buttonup'));\n            }\n            if (!this.input[type] && input[type]) {\n                core.dispatchEvent(new enchant.Event(type + 'buttondown'));\n            }\n        }, this);\n        this.input = input;\n    }\n});\n\n/**\n * アナログパッドのクラス: APad\n * @scope enchant.ui.APad\n */\nenchant.ui.APad = enchant.Class.create(enchant.Group, {\n    /**\n     * アナログパッドオブジェクトを作成する。\n     * @constructs\n     * @extends enchant.Group\n     * @param mode\n     *   'direct': 入力ベクトルは正規化されない (大きさは 0~1 の間)\n     *   'normal': 入力ベクトルを常に正規化する (大きさは常に1となる)\n     */\n    initialize: function(mode) {\n        var core = enchant.Core.instance;\n        var image = core.assets['apad.png'];\n        var w = this.width = image.width;\n        var h = this.height = image.height;\n        enchant.Group.call(this);\n\n        this.outside = new enchant.Sprite(w, h);\n        var outsideImage = new enchant.Surface(w, h);\n        outsideImage.draw(image, 0, 0, w, h / 4, 0, 0, w, h / 4);\n        outsideImage.draw(image, 0, h / 4 * 3, w, h / 4, 0, h / 4 * 3, w, h / 4);\n        outsideImage.draw(image, 0, h / 4, w / 4, h / 2, 0, h / 4, w / 4, h / 2);\n        outsideImage.draw(image, w / 4 * 3, h / 4, w / 4, h / 2, w / 4 * 3, h / 4, w / 4, h / 2);\n        this.outside.image = outsideImage;\n        this.inside = new enchant.Sprite(w / 2, h / 2);\n        var insideImage = new enchant.Surface(w / 2, h / 2);\n        insideImage.draw(image, w / 4, h / 4, w / 2, h / 2, 0, 0, w / 2, h / 2);\n        this.inside.image = insideImage;\n        this.r = w / 2;\n\n        /**\n         * isTouched\n         * @type {Boolean}\n         * タッチされているかどうか\n         */\n        this.isTouched = false;\n\n        /**\n         * vx, vy\n         * @type {Number}\n         * 入力ベクトルの(x, y)方向の大きさ\n         */\n        this.vx = 0;\n        this.vy = 0;\n\n        /**\n         * rad, dist\n         * @type {Number}\n         * 入力ベクトルの極座標表示\n         * radは角度、distはベクトルの大きさを示す\n         */\n        this.rad = 0;\n        this.dist = 0;\n\n        if (mode === 'direct') {\n            this.mode = 'direct';\n        } else {\n            this.mode = 'normal';\n        }\n        this._updateImage();\n        this.addChild(this.inside);\n        this.addChild(this.outside);\n        this.addEventListener('touchstart', function(e) {\n            this._detectInput(e.localX, e.localY);\n            this._calcPolar(e.localX, e.localY);\n            this._updateImage(e.localX, e.localY);\n            this._dispatchPadEvent('apadstart');\n            this.isTouched = true;\n        });\n        this.addEventListener('touchmove', function(e) {\n            this._detectInput(e.localX, e.localY);\n            this._calcPolar(e.localX, e.localY);\n            this._updateImage(e.localX, e.localY);\n            this._dispatchPadEvent('apadmove');\n        });\n        this.addEventListener('touchend', function(e) {\n            this._detectInput(this.width / 2, this.height / 2);\n            this._calcPolar(this.width / 2, this.height / 2);\n            this._updateImage(this.width / 2, this.height / 2);\n            this._dispatchPadEvent('apadend');\n            this.isTouched = false;\n        });\n    },\n    _dispatchPadEvent: function(type) {\n        var e = new enchant.Event(type);\n        e.vx = this.vx;\n        e.vy = this.vy;\n        e.rad = this.rad;\n        e.dist = this.dist;\n        this.dispatchEvent(e);\n    },\n    _updateImage: function(x, y) {\n        x -= this.width / 2;\n        y -= this.height / 2;\n        this.inside.x = this.vx * (this.r - 10) + 25;\n        this.inside.y = this.vy * (this.r - 10) + 25;\n    },\n    _detectInput: function(x, y) {\n        x -= this.width / 2;\n        y -= this.height / 2;\n        var distance = Math.sqrt(x * x + y * y);\n        var tan = y / x;\n        var rad = Math.atan(tan);\n        var dir = x / Math.abs(x);\n        if (distance === 0) {\n            this.vx = 0;\n            this.vy = 0;\n        } else if (x === 0) {\n            this.vx = 0;\n            if (this.mode === 'direct') {\n                this.vy = (y / this.r);\n            } else {\n                dir = y / Math.abs(y);\n                this.vy = Math.pow((y / this.r), 2) * dir;\n            }\n        } else if (distance < this.r) {\n            if (this.mode === 'direct') {\n                this.vx = (x / this.r);\n                this.vy = (y / this.r);\n            } else {\n                this.vx = Math.pow((distance / this.r), 2) * Math.cos(rad) * dir;\n                this.vy = Math.pow((distance / this.r), 2) * Math.sin(rad) * dir;\n            }\n        } else {\n            this.vx = Math.cos(rad) * dir;\n            this.vy = Math.sin(rad) * dir;\n        }\n    },\n    _calcPolar: function(x, y) {\n        x -= this.width / 2;\n        y -= this.height / 2;\n        var add = 0;\n        var rad = 0;\n        var dist = Math.sqrt(x * x + y * y);\n        if (dist > this.r) {\n            dist = this.r;\n        }\n        dist /= this.r;\n        if (this.mode === 'normal') {\n            dist *= dist;\n        }\n        if (x >= 0 && y < 0) {\n            add = Math.PI / 2 * 3;\n            rad = x / y;\n        } else if (x < 0 && y <= 0) {\n            add = Math.PI;\n            rad = y / x;\n        } else if (x <= 0 && y > 0) {\n            add = Math.PI / 2;\n            rad = x / y;\n        } else if (x > 0 && y >= 0) {\n            add = 0;\n            rad = y / x;\n        }\n        if (x === 0 || y === 0) {\n            rad = 0;\n        }\n        this.rad = Math.abs(Math.atan(rad)) + add;\n        this.dist = dist;\n    }\n});\n\n/**\n * ボタンオブジェクトのクラス: Button\n * available in only DOMGroup\n *\n * @scope enchant.ui.Button.prototype\n * @deprecated\n * @classes\n */\nenchant.ui.Button = enchant.Class.create(enchant.Entity, {\n    /**\n     * ボタンオブジェクトを作成する。\n     * @constructs\n     * @extends enchant.Entity\n     */\n    initialize: function(text, theme, height, width) {\n        enchant.Entity.call(this);\n\n        if (enchant.CanvasLayer) {\n            this._element = 'div';\n        }\n\n        this.width = width || null;\n        this.height = height || null;\n        this.text = text;\n        this.pressed = false;\n\n        // デフォルトのスタイル (テーマで上書き可能)\n        var style = this._style;\n        style[\"display\"] = \"inline-block\";\n        style[\"font-size\"] = \"12px\";\n        style[\"height\"] = \"2em\";\n        style[\"line-height\"] = \"2em\";\n        style[\"min-width\"] = \"2em\";\n        style[\"padding\"] = \"2px 10px\";\n        style[\"text-align\"] = \"center\";\n        style[\"font-weight\"] = \"bold\";\n        style[\"border-radius\"] = \"0.5em\";\n\n        // テーマの指定がなければ \"dark\" を使う\n        theme = theme || \"dark\";\n\n        if (typeof theme === \"string\") {\n            // theme 引数が string なら、その名前のデフォルトテーマを使う\n            this.theme = enchant.ui.Button.DEFAULT_THEME[theme];\n        } else {\n            // theme 引数が object なら、その引数をテーマとして扱う\n            this.theme = theme;\n        }\n\n        // テーマを適用する\n        this._applyTheme(this.theme.normal);\n\n        // タッチしたときの挙動\n        this.addEventListener(\"touchstart\", function() {\n            this._applyTheme(this.theme.active);\n            this.pressed = true;\n            this.y++;\n        });\n\n        // タッチが離されたときの挙動\n        this.addEventListener(\"touchend\", function() {\n            this._applyTheme(this.theme.normal);\n            this.pressed = false;\n            this.y--;\n        });\n    },\n    _applyTheme: function(theme) {\n        var style = this._style;\n        var css = enchant.ui.Button.theme2css(theme);\n        for (var i in css) {\n            if (css.hasOwnProperty(i)) {\n                style[i] = css[i];\n            }\n        }\n    },\n    /**\n     * 表示するテキスト\n     * @type {String}\n     */\n    text: {\n        get: function() {\n            return this._text;\n        },\n        set: function(text) {\n                this._text = text;\n            if (!enchant.CanvasLayer) {\n                this._element.innerHTML = text;\n            }\n        }\n    },\n    /**\n     * フォントサイズ\n     */\n    size: {\n        get: function() {\n            return this._style.fontSize;\n        },\n        set: function(size) {\n            this._style.fontSize = size;\n        }\n    },\n    /**\n     * フォントの指定\n     * @type {String}\n     */\n    font: {\n        get: function() {\n            return this._style.font;\n        },\n        set: function(font) {\n            this._style.font = font;\n        }\n    },\n    /**\n     * Text color settings.\n     * CSS 'color' can be set to same format as properties.\n     * @type {String}\n     */\n    color: {\n        get: function() {\n            return this._style.color;\n        },\n        set: function(color) {\n            this._style.color = color;\n        }\n    },\n    cvsRender: function() {\n        // not available now\n    },\n    domRender: function() {\n        var element = this._domManager.element;\n        element.innerHTML = this._text;\n        element.style.font = this._font;\n        element.style.color = this._color;\n        element.style.textAlign = this._textAlign;\n    }\n});\n\nenchant.ui.Button.theme2css = function(theme) {\n    var prefix = '-' + enchant.ENV.VENDOR_PREFIX.toLowerCase() + '-';\n    var obj = {};\n    var bg = theme.background;\n    var bd = theme.border;\n    var ts = theme.textShadow;\n    var bs = theme.boxShadow;\n    if (prefix === '-ms-') {\n        obj['background'] = bg.start;\n    } else {\n        obj['background-image'] = prefix + bg.type + '('+ [ 'top', bg.start, bg.end ] + ')';\n    }\n    obj['color'] = theme.color;\n    obj['border'] = bd.color + ' ' + bd.width + ' ' + bd.type;\n    obj['text-shadow'] = ts.offsetX + 'px ' + ts.offsetY + 'px ' + ts.blur + ' ' + ts.color;\n    obj['box-shadow'] = bs.offsetX + 'px ' + bs.offsetY + 'px ' + bs.blur + ' ' + bs.color;\n    return obj;\n};\n\nenchant.ui.Button.DEFAULT_THEME = {\n    dark: {\n        normal: {\n            color: '#fff',\n            background: { type: 'linear-gradient', start: '#666', end: '#333' },\n            border: { color: '#333', width: 1, type: 'solid' },\n            textShadow: { offsetX: 0, offsetY: 1, blur: 0, color: '#666' },\n            boxShadow: { offsetX: 0, offsetY: 1, blur: 0, color: 'rgba(255, 255, 255, 0.3)' }\n        },\n        active: {\n            color: '#ccc',\n            background: { type: 'linear-gradient', start: '#333', end: '#000' },\n            border: { color: '#333', width: 1, type: 'solid' },\n            textShadow: { offsetX: 0, offsetY: 1, blur: 0, color: '#000' },\n            boxShadow: { offsetX: 0, offsetY: 1, blur: 0, color: 'rgba(255, 255, 255, 0.3)' }\n        }\n    },\n    light: {\n        normal: {\n            color: '#333',\n            background: { type: 'linear-gradient', start: '#fff', end:'#ccc' },\n            border: { color: '#999', width: 1, type: 'solid' },\n            textShadow: { offsetX: 0, offsetY: 1, blur: 0, color: '#fff' },\n            boxShadow: { offsetX: 0, offsetY: 1, blur: 0, color: 'rgba(0, 0, 0, 1)' },\n        },\n        active: {\n            color: '#333',\n            background: { type: 'linear-gradient', start: '#ccc', end: '#999' },\n            border: { color: '#666', width: 1, type: 'solid' },\n            textShadow: { offsetX: 0, offsetY: 1, blur: 0, color: '#ccc' },\n            boxShadow: { offsetX: 0, offsetY: 1, blur: 0, color: 'rgba(255, 255, 255, 0.3)' }\n        }\n    },\n    blue: {\n        normal: {\n            color: '#fff',\n            background: { type: 'linear-gradient', start: '#04f', end: '#04c' },\n            border: { color: '#026', width: 1, type: 'solid' },\n            textShadow: { offsetX: 0, offsetY: 1, blur: 0, color: '#666' },\n            boxShadow: { offsetX: 0, offsetY: 1, blur: 0, color: 'rgba(0, 0, 0, 0.5)' }\n        },\n        active: {\n            color: '#ccc',\n            background: { type: 'linear-gradient', start: '#029', end: '#026' },\n            border: { color: '#026', width: 1, type: 'solid' },\n            textShadow: { offsetX: 0, offsetY: 1, blur: 0, color: '#000' },\n            boxShadow: 'none'\n        }\n    }\n};\n\n/**\n * @scope enchant.ui.MutableText.prototype\n * @type {*}\n */\nenchant.ui.MutableText = enchant.Class.create(enchant.Sprite, {\n    /**\n     *\n     * @usage\n     *     var text = new MutableText(0, 0);\n     *     game.text = 'Hello, world!';\n     *     game.rootScene.addChild(text);\n     *\n     * @constructs\n     * @param posX\n     * @param posY\n     * @param width\n     */\n    initialize: function(x, y, width) {\n        enchant.Sprite.call(this, 0, 0);\n        this.fontSize = 16;\n        this.widthItemNum = 16;\n        this.x = x;\n        this.y = y;\n        this._imageAge = Number.MAX_VALUE;\n        this.text = '';\n        if (arguments[2]) {\n            this.row = Math.floor(arguments[2] / this.fontSize);\n        }\n    },\n    /**\n     * ラベルの内容を書き換える関数\n     * @param txt\n     */\n    setText: function(txt) {\n        var i, x, y, wNum, charCode, charPos;\n        this._text = txt;\n        var newWidth;\n        if (!this.returnLength) {\n            this.width = Math.min(this.fontSize * this._text.length, enchant.Game.instance.width);\n        } else {\n            this.width = Math.min(this.returnLength * this.fontSize, enchant.Game.instance.width);\n        }\n        this.height = this.fontSize * (Math.ceil(this._text.length / this.row) || 1);\n        // if image is to small or was to big for a long time create new image\n        if(!this.image || this.width > this.image.width || this.height > this.image.height || this._imageAge > 300) {\n            this.image = new enchant.Surface(this.width, this.height);\n            this._imageAge = 0;\n        } else if(this.width < this.image.width || this.height < this.image.height) {\n            this._imageAge++;\n        } else {\n            this._imageAge = 0;\n        }\n        this.image.context.clearRect(0, 0, this.width, this.height);\n        for (i = 0; i < txt.length; i++) {\n            charCode = txt.charCodeAt(i);\n            if (charCode >= 32 && charCode <= 127) {\n                charPos = charCode - 32;\n            } else {\n                charPos = 0;\n            }\n            x = charPos % this.widthItemNum;\n            y = (charPos / this.widthItemNum) | 0;\n            this.image.draw(enchant.Game.instance.assets['font0.png'],\n                x * this.fontSize, y * this.fontSize, this.fontSize, this.fontSize,\n                (i % this.row) * this.fontSize, ((i / this.row) | 0) * this.fontSize, this.fontSize, this.fontSize);\n        }\n    },\n    /**\n     * ラベルの内容\n     * @type {String}\n     */\n    text: {\n        get: function() {\n            return this._text;\n        },\n        set: function(txt) {\n            this.setText(txt);\n        }\n    },\n    /**\n     * @type {Number}\n     */\n    row: {\n        get: function() {\n            return this.returnLength || this.width / this.fontSize;\n        },\n        set: function(row) {\n            this.returnLength = row;\n            this.text = this.text;\n        }\n    }\n});\n\n/**\n * @scope enchant.ui.ScoreLabel.prototype\n * @type {*}\n */\nenchant.ui.ScoreLabel = enchant.Class.create(enchant.ui.MutableText, {\n    /**\n     * スコアを表示するラベル。\n     * 画像フォントクラス (MutableText) を使って表示する。\n     * @constructs\n     * @param x\n     * @param y\n     */\n    initialize: function(x, y) {\n        enchant.ui.MutableText.call(this, 0, 0);\n        switch (arguments.length) {\n            case 2:\n                this.y = y;\n                this.x = x;\n                break;\n            case 1:\n                this.x = x;\n                break;\n            default:\n                break;\n        }\n        this._score = 0;\n        this._current = 0;\n        this.easing = 2.5;\n        this.text = this.label = 'SCORE:';\n        this.addEventListener('enterframe', function() {\n            if (this.easing === 0) {\n                this.text = this.label + (this._current = this._score);\n            } else {\n                this._current += Math.ceil((this._score - this._current) / this.easing);\n                this.text = this.label + this._current;\n            }\n        });\n    },\n    /**\n     * スコア\n     * @type {Number}\n     */\n    score: {\n        get: function() {\n            return this._score;\n        },\n        set: function(newscore) {\n            this._score = newscore;\n        }\n    }\n});\n\n/**\n * @type {*}\n * @scope enchant.ui.TimeLabel.prototype\n */\nenchant.ui.TimeLabel = enchant.Class.create(enchant.ui.MutableText, {\n    /**\n     * 残り時間などのタイムを表示するラベル\n     * @constructs\n     * @param x\n     * @param y\n     * @param counttype\n     */\n    initialize: function(x, y, counttype) {\n        enchant.ui.MutableText.call(this, 0, 0);\n        switch (arguments.length) {\n            case 3:\n            case 2:\n                this.y = y;\n                this.x = x;\n                break;\n            case 1:\n                this.x = x;\n                break;\n            default:\n                break;\n        }\n        this._time = 0;\n        this._count = 1;// この数を毎フレーム每に足して上げ下げを制御する\n        if (counttype === 'countdown') {\n            this._count = -1;\n        }\n        this.text = this.label = 'TIME:';\n        this.addEventListener('enterframe', function() {\n            this._time += this._count;\n            this.text = this.label + (this._time / enchant.Game.instance.fps).toFixed(2);\n        });\n    },\n    /**\n     * 残り時間\n     * @type {Number}\n     */\n    time: {\n        get: function() {\n            return Math.floor(this._time / enchant.Game.instance.fps);\n        },\n        set: function(newtime) {\n            this._time = newtime * enchant.Game.instance.fps;\n        }\n    }\n});\n\n/**\n * @type {*}\n * @scope enchant.ui.LifeLabel.prototype\n */\nenchant.ui.LifeLabel = enchant.Class.create(enchant.Group, {\n    /**\n     * ライフを表示する専用のラベル\n     * icon0.png 内のハートの画像を用いる\n     * @constructs\n     * @param x\n     * @param y\n     * @param maxlife\n     */\n    initialize: function(x, y, maxlife) {\n        enchant.Group.call(this);\n        this.x = x || 0;\n        this.y = y || 0;\n        this._maxlife = maxlife || 9;\n        this._life = 0;\n        this.label = new enchant.ui.MutableText(0, 0, 80);\n        this.label.text = 'LIFE:';\n        this.addChild(this.label);\n        this.heart = [];\n        for (var i = 0; i < this._maxlife; i++) {\n            this.heart[i] = new enchant.Sprite(16, 16);\n            this.heart[i].image = enchant.Game.instance.assets['icon0.png'];\n            this.heart[i].x = this.label.width + i * 16;\n            this.heart[i].y = -3;\n            this.heart[i].frame = 10;\n            this.addChild(this.heart[i]);\n        }\n    },\n    /**\n     * 残りライフの数\n     * @type {Number}\n     */\n    life: {\n        get: function() {\n            return this._life;\n        },\n        set: function(newlife) {\n            this._life = newlife;\n            if (this._maxlife < newlife) {\n                this._life = this._maxlife;\n            }\n            for (var i = 0; i < this._maxlife; i++) {\n                this.heart[i].visible = (i <= newlife - 1);\n            }\n        }\n    }\n});\n\n/**\n * @scope enchant.ui.Bar\n * @type {*}\n */\nenchant.ui.Bar = enchant.Class.create(enchant.Sprite, {\n    /**\n     * イージング付きのバークラス\n     * @constructs\n     * @param x\n     * @param y\n     */\n    initialize: function(x, y) {\n        enchant.Sprite.call(this, 1, 16);\n        this.image = new enchant.Surface(1, 16);// Null用\n        this.image.context.fillColor = 'RGB(0, 0, 256)';\n        this.image.context.fillRect(0, 0, 1, 16);\n        this._direction = 'right';\n        this._origin = 0;\n        this._maxvalue = enchant.Game.instance.width;\n        this._lastvalue = 0;\n        this.value = 0;\n        this.easing = 5;\n        switch (arguments.length) {\n            case 2:\n                this.y = y;\n                this.x = x;\n                this._origin = x;\n                break;\n            case 1:\n                this.x = x;\n                this._origin = x;\n                break;\n            default:\n                break;\n        }\n        this.addEventListener('enterframe', function() {\n            if (this.value < 0) {\n                this.value = 0;\n            }\n            this._lastvalue += (this.value - this._lastvalue) / this.easing;\n            if (Math.abs(this._lastvalue - this.value) < 1.3) {\n                this._lastvalue = this.value;\n            }\n            this.width = (this._lastvalue) | 0;\n            if (this.width > this._maxvalue) {\n                this.width = this._maxvalue;\n            }\n            if (this._direction === 'left') {\n                this._x = this._origin - this.width;\n            } else {\n                this._x = this._origin;\n            }\n            this._updateCoordinate();\n        });\n    },\n    /**\n     * バーの向き ('right' or 'left')\n     * @default 'right'\n     * @type {String}\n     */\n    direction: {\n        get: function() {\n            return this._direction;\n        },\n        set: function(newdirection) {\n            if (newdirection !== 'right' && newdirection !== 'left') {\n                // ignore\n            } else {\n                this._direction = newdirection;\n            }\n        }\n    },\n    /**\n     * x 座標\n     * @type {Number}\n     */\n    x: {\n        get: function() {\n            return this._origin;\n        },\n        set: function(x) {\n            this._x = x;\n            this._origin = x;\n            this._dirty = true;\n        }\n    },\n    /**\n     * @type {Number}\n     */\n    maxvalue: {\n        get: function() {\n            return this._maxvalue;\n        },\n        set: function(val) {\n            this._maxvalue = val;\n        }\n    }\n});\n\n/**\n * @scope enchant.ui.VirtualMap.prototype\n */\nenchant.ui.VirtualMap = enchant.Class.create(enchant.Group, {\n    /**\n     * マップライクな Group\n     * addChildで Sprite 等を追加すると、自動的に mx, my プロパティが追加され、\n     * VirtualMap内での座標で Sprite を操作できる\n     *\n     * 使い方\n     * //20 x 20 メッシュの縦横320ピクセルの盤を作り、その上に16 x 16の駒を8つ並べる\n     * var board = new VirtualMap(20, 20);\n     * board.width = 320;\n     * board.height = 320;\n     * for(var i=0; i<8; i++){\n     *     var piece = new Sprite(16, 16);\n     *     piece.image = game.assets['icon0.gif'];\n     *     board.addChild(piece);\n     *     piece.mx = i + 3;\n     *     piece.my = 16;\n     * }\n     * game.rootScene.addChild(board);\n     *\n     * @param meshWidth\n     * @param meshHeight\n     * @constructs\n     */\n    initialize: function(meshWidth, meshHeight) {\n        enchant.Group.call(this);\n        this.meshWidth = meshWidth || 16;\n        this.meshHeight = meshHeight || 16;\n    },\n    /**\n     * VirtualMap にオブジェクトを追加する (自動的にバインドされる)\n     * @param obj\n     */\n    addChild: function(obj) {\n        enchant.Group.prototype.addChild.call(this, obj);\n        this.bind(obj);\n    },\n    /**\n     * VirtualMap にオブジェクトを追加する\n     * reference で指定したオブジェクトより前に追加される (自動的にバインドされる)。\n     * @param obj\n     * @param reference\n     */\n    insertBefore: function(obj, reference) {\n        enchant.Group.prototype.insertBefore.call(this, obj, reference);\n        this.bind(obj);\n    },\n    /**\n     * オブジェクトを VirtualMap にバインドする。\n     * バインドされたオブジェクトはメッシュ座標 mx, my プロパティを持ち、これを操作することで\n     * VirtualMap の中を移動させることができる。\n     * @param obj\n     */\n    bind: function(obj) {\n        Object.defineProperties(obj, {\n            \"mx\": {\n                get: function() {\n                    return Math.floor(this.x / this.parentNode.meshWidth);\n                },\n                set: function(arg) {\n                    this.x = Math.floor(arg * this.parentNode.meshWidth);\n                }\n            },\n            \"my\": {\n                get: function() {\n                    return Math.floor(this.y / this.parentNode.meshHeight);\n                },\n                set: function(arg) {\n                    this.y = Math.floor(arg * this.parentNode.meshWidth);\n                }\n            }\n        });\n        obj.mx = 0;\n        obj.my = 0;\n    }\n});\n\nfunction rand(num) {\n    return Math.floor(Math.random() * num);\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":27003}]],"length":27003}
